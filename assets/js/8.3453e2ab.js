(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{176:function(e,t,r){e.exports=r.p+"assets/img/switch-node-example.5317e685.png"},177:function(e,t,r){e.exports=r.p+"assets/img/switch-node-rules.1518490b.png"},273:function(e,t,r){"use strict";r.r(t);var n={props:["slot-key"],mounted:function(){this.$nextTick(function(){this.$vuepress.$emit("AsyncMarkdownContentMounted",this.slotKey)})}},a=r(6),i=Object(a.a)(n,function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.slotKey}},[n("h1",{attrs:{id:"switch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#switch","aria-hidden":"true"}},[e._v("#")]),e._v(" switch")]),e._v(" "),n("p",[e._v("Die "),n("code",[e._v("ccu switch")]),e._v(" Node verhält sich ähnlich wie die "),n("a",{attrs:{href:"https://nodered.org/docs/user-guide/nodes#switch",target:"_blank",rel:"noopener noreferrer"}},[e._v("switch"),n("OutboundLink")],1),e._v(" Node von Node-RED. Sie führt einen Flow auf einem von mehreren Outputs fort, abhängig von einem Zustand eines Aktors oder einer Systemvariablen.")]),e._v(" "),n("p",[e._v("Beispiel: Ein Tastendruck initiiert den Flow. Ist von Kanal "),n("code",[e._v("Gang Licht")]),e._v(" der Datenpunkt "),n("code",[e._v("STATE")]),e._v(" gleich "),n("code",[e._v("true")]),e._v(" (also Licht ist an), fahre an Output 1 fort, ansonsten Output 2. An Output 1 hängt eine eine "),n("a",{attrs:{href:"https://nodered.org/docs/user-guide/nodes#change",target:"_blank",rel:"noopener noreferrer"}},[e._v("change"),n("OutboundLink")],1),e._v(" Node welche die Payload auf "),n("code",[e._v("false")]),e._v(" ändert. An Output 2 eine "),n("code",[e._v("change")]),e._v(" Node die den Payload auf "),n("code",[e._v("true")]),e._v(" ändert. Beide Nodes sind mit einer "),n("router-link",{attrs:{to:"./value.html"}},[e._v("value")]),e._v(" Node verbunden welche den "),n("code",[e._v("STATE")]),e._v(" vom Kanal "),n("code",[e._v("Gang Licht")]),e._v(" setzt. Nun hat man einen Taster geschaffen welcher das Licht im Gang aus bzw. ein schaltet.")],1),e._v(" "),n("p",[n("img",{attrs:{src:r(176),alt:"switch example"}})]),e._v(" "),n("h2",{attrs:{id:"attribute"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#attribute","aria-hidden":"true"}},[e._v("#")]),e._v(" Attribute")]),e._v(" "),n("h3",{attrs:{id:"name"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#name","aria-hidden":"true"}},[e._v("#")]),e._v(" Name")]),e._v(" "),n("p",[e._v("Der Name dient zur Beschriftung des Node im Flow.")]),e._v(" "),n("h3",{attrs:{id:"ccu"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#ccu","aria-hidden":"true"}},[e._v("#")]),e._v(" CCU")]),e._v(" "),n("p",[e._v("Die zu verwendende CCU-Konfiguration.")]),e._v(" "),n("h3",{attrs:{id:"interface"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#interface","aria-hidden":"true"}},[e._v("#")]),e._v(" Interface")]),e._v(" "),n("p",[e._v("Hier wird das Interface gewählt, welches das Event erzeugt hat.")]),e._v(" "),n("h3",{attrs:{id:"channel"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channel","aria-hidden":"true"}},[e._v("#")]),e._v(" Channel")]),e._v(" "),n("p",[e._v("Der Kanal von dem der Datenpunkte abgefragt werden solln."),n("br"),e._v("\nEine Autovervollständigung hilft bei der Auswahl anhand der Klarnamen.")]),e._v(" "),n("h3",{attrs:{id:"datapoint"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#datapoint","aria-hidden":"true"}},[e._v("#")]),e._v(" Datapoint")]),e._v(" "),n("p",[e._v("Der Datenpunkt des Kanals, auch hier wird über eine Autovervollständigung die Auswahl vereinfacht.")]),e._v(" "),n("h3",{attrs:{id:"property"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#property","aria-hidden":"true"}},[e._v("#")]),e._v(" Property")]),e._v(" "),n("p",[e._v("Hier wird das spezifische Property des Datenpunkts ausgewählt:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("value")]),e._v(": Der reale Wert")]),e._v(" "),n("li",[n("code",[e._v("ts")]),e._v(": Der aktuelle Timestamp")]),e._v(" "),n("li",[n("code",[e._v("lc")]),e._v(": Der Timestamp der letzten Aktualisierung")]),e._v(" "),n("li",[n("code",[e._v("working")]),e._v(": Gibt an, ob sich der Aktor gerade im Schaltvorgang befindet")]),e._v(" "),n("li",[n("code",[e._v("direction")]),e._v(": Gibt die Richtung an in der sich z.B. ein Rollladen im Moment bewegt")])]),e._v(" "),n("h3",{attrs:{id:"regeln"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#regeln","aria-hidden":"true"}},[e._v("#")]),e._v(" Regeln")]),e._v(" "),n("p",[e._v("Für jeden Output wird Bedingung definiert.")]),e._v(" "),n("p",[e._v("Der Operator (z.B. "),n("code",[e._v("==")]),e._v(" oder "),n("code",[e._v("<=")]),e._v(") gibt die Art des Vergleichs an. Je nach Operator wird daneben der Vergleichswert gewählt. Er kann aus verschiedenen Quellen kommen, zum Beispiel über Eingabe als String oder Number, aus einem anderen Property von "),n("code",[e._v("msg")]),e._v(", aus einem "),n("a",{attrs:{href:"https://nodered.org/docs/user-guide/context",target:"_blank",rel:"noopener noreferrer"}},[e._v("Context"),n("OutboundLink")],1),e._v(" und weiteren.")]),e._v(" "),n("p",[n("img",{attrs:{src:r(177),alt:"switch node rules"}})]),e._v(" "),n("p",[e._v("Es können beliebig viele Rules und damit Outputs angelegt werden.")]),e._v(" "),n("p",[e._v("Verahlten des Matchers:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("checking all rules")]),e._v(": Es werden Events an allen Outputs erzeugt, an denen der Vergleich zutrifft")]),e._v(" "),n("li",[n("code",[e._v("stopping after first match")]),e._v(": Der erste zutreffende Vergleich erzeugt ein Event, es werden keine weiteren Prüfungen durchlaufen.")])])])},[],!1,null,null,null);i.options.__file="switch.md";t.default=i.exports}}]);